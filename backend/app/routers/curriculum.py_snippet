
# --- YOUTUBE INGESTION ---
from pydantic import BaseModel

class YoutubeIngestRequest(BaseModel):
    url: str

@router.post("/ingest_youtube")
async def ingest_youtube(
    payload: YoutubeIngestRequest,
    db: Session = Depends(get_db)
):
    """
    Download a YouTube video and ingest it into the corpus.
    Downloads 720p (or best available <= 720p) to save space/time.
    """
    url = payload.url
    
    # 1. Download via yt-dlp
    import yt_dlp
    from fastapi.concurrency import run_in_threadpool
    
    def download_sync():
        ydl_opts = {
            'format': 'bestvideo[height<=720][ext=mp4]+bestaudio[ext=m4a]/best[height<=720][ext=mp4]/best[ext=mp4]',
            'outtmpl': os.path.join(DATA_DIR, '%(title)s.%(ext)s'),
            'restrictfilenames': True, # Ensure filenames are safe (ASCII)
            'noplaylist': True,
        }
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=True)
            # Get actual filename
            filename = ydl.prepare_filename(info)
            return filename, info.get('title', 'Unknown')

    try:
        # Run download in threadpool (it blocks)
        filename, title = await run_in_threadpool(download_sync)
        
        # Verify file exist (sometimes ffmpeg merge changes extension)
        # yt-dlp usually returns the correct 'prepare_filename' but let's verify
        if not os.path.exists(filename):
            # Try finding it if extension changed (e.g. .mkv)
            # But we forced [ext=mp4] so it should be fine.
            pass

        # 2. Rename to UUID for consistency? 
        # Actually, user might want to see the title.
        # But 'ingest_video' uses UUID.
        # Let's keep the safe filename from yt-dlp, it's usually readable but safe.
        
        final_filename = os.path.basename(filename)
        
        # 3. Create DB Entry
        video = k_models.VideoCorpus(
            filename=final_filename,
            file_path=filename,
            status=k_models.DocStatus.PENDING
        )
        db.add(video)
        db.commit()
        db.refresh(video)
        
        # 4. Trigger Ingestion (Redis)
        import redis
        REDIS_URL = os.getenv("REDIS_URL", "redis://redis:6379/0")
        try:
            r = redis.from_url(REDIS_URL)
            r.publish("corpus_jobs", str(video.id))
        except Exception as e:
            print(f"Redis Publish Error: {e}")
            # Non-critical, cron can pick it up or user can re-queue?
            # actually we should error if we can't process
            
        return {"status": "uploaded", "id": video.id, "filename": final_filename, "title": title}
            
    except Exception as e:
        print(f"YouTube Download Error: {e}")
        raise HTTPException(status_code=500, detail=f"YouTube Download Failed: {str(e)}")
