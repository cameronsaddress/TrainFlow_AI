from docx import Document
from fpdf import FPDF
import json
import os
from ..models.models import ProcessFlow

def export_to_json(flow: ProcessFlow):
    """
    Export flow to JSON format.
    """
    return {
        "id": flow.id,
        "title": flow.title,
        "description": flow.description,
        "steps": [
            {
                "step": s.step_number,
                "action": s.action_details,
                "system": s.system_name,
                "duration": s.duration
            }
            for s in flow.steps
        ]
    }

def export_to_docx(flow: ProcessFlow, output_path: str):
    """
    Export flow to Word Document.
    """
    doc = Document()
    doc.add_heading(flow.title, 0)
    
    doc.add_paragraph(flow.description)
    
    doc.add_heading('Step-by-Step Guide', level=1)
    
    table = doc.add_table(rows=1, cols=3)
    hdr_cells = table.rows[0].cells
    hdr_cells[0].text = 'Step'
    hdr_cells[1].text = 'Action'
    hdr_cells[2].text = 'System'
    
    for step in flow.steps:
        row_cells = table.add_row().cells
        row_cells[0].text = str(step.step_number)
        row_cells[1].text = step.action_details or ""
        row_cells[2].text = step.system_name or ""
        
    doc.save(output_path)
    return output_path

def export_to_pdf(flow: ProcessFlow, output_path: str):
    """
    Export flow to PDF.
    """
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=12)
    pdf.cell(200, 10, txt=flow.title, ln=1, align="C")
    
    for step in flow.steps:
        line = f"{step.step_number}. {step.action_details} ({step.system_name})"
        pdf.cell(200, 10, txt=line, ln=1, align="L")
        
    pdf.output(output_path)
    return output_path

from pptx import Presentation
from pptx.util import Inches, Pt

def export_to_pptx(flow: ProcessFlow, output_path: str):
    """
    Export flow to PowerPoint (.pptx).
    """
    prs = Presentation()
    
    # 1. Title Slide
    title_slide_layout = prs.slide_layouts[0]
    slide = prs.slides.add_slide(title_slide_layout)
    title = slide.shapes.title
    subtitle = slide.placeholders[1]
    
    title.text = flow.title
    subtitle.text = flow.description or "Generated by TrainFlow AI"
    
    # 2. Step Slides
    bullet_slide_layout = prs.slide_layouts[1] # Title and Content
    
    for step in flow.steps:
        slide = prs.slides.add_slide(bullet_slide_layout)
        shapes = slide.shapes
        
        # Title
        title_shape = shapes.title
        title_shape.text = f"Step {step.step_number}: {step.action_details}"
        
        # Body / Content
        body_shape = shapes.placeholders[1]
        tf = body_shape.text_frame
        tf.text = f"System: {step.system_name}"
        
        p = tf.add_paragraph()
        p.text = f"Expected Result: {step.expected_result}"
        p.level = 1
        
        if step.notes:
            p = tf.add_paragraph()
            p.text = f"Notes: {step.notes}"
            p.level = 1
            
        # Add Screenshot if available
        # Ideally, we would download the screenshot from MinIO/S3 if it's a URL, 
        # but for this prototype assumption, we check if it's a local path or handle URL later.
        # Here we'll skip image insertion if path is not local/valid to prevent crash.
        # Implementation Detail: In production, download image to temp first.
        pass 
        
    prs.save(output_path)
    return output_path

def export_to_html(flow: ProcessFlow, embed_clips: bool = False) -> str:
    """
    FR-17: Generate HTML string for the guide.
    If embed_clips is True, adds <video> tags pointing to relative 'clips/' directory.
    """
    html = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>{flow.title}</title>
        <style>
            body {{ font-family: sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }}
            .step {{ border: 1px solid #ddd; padding: 15px; margin-bottom: 20px; border-radius: 5px; }}
            .step-header {{ display: flex; justify-content: space-between; font-weight: bold; background: #f9f9f9; padding: 10px; }}
            .action {{ font-size: 1.2em; margin: 10px 0; }}
            .system {{ color: #666; font-size: 0.9em; }}
            video {{ max-width: 100%; margin-top: 10px; border: 1px solid #ccc; }}
        </style>
    </head>
    <body>
        <h1>{flow.title}</h1>
        <p>{flow.description or ''}</p>
        <hr/>
    """
    
    sorted_steps = sorted(flow.steps, key=lambda s: s.step_number)
    for step in sorted_steps:
        # Resolve Clip Path
        video_tag = ""
        if embed_clips and step.video_clip_path:
             # Assume step.video_clip_path is absolute or relative from root.
             # We need just the filename for the SCORM/HTML relative link.
             filename = os.path.basename(step.video_clip_path)
             if filename and filename != "placeholder.mp4":
                 video_tag = f"""
                 <div class="video-container">
                    <video controls>
                        <source src="clips/{filename}" type="video/mp4">
                        Your browser does not support the video tag.
                    </video>
                 </div>
                 """

        html += f"""
        <div class="step">
            <div class="step-header">
                <span>Step {step.step_number}</span>
                <span class="system">{step.system_name or 'System'}</span>
            </div>
            <div class="action">{step.action_details}</div>
            {video_tag}
            <div class="result"><strong>Expected Result:</strong> {step.expected_result}</div>
            {f'<div class="notes">Note: {step.notes}</div>' if step.notes else ''}
        </div>
        """
        
    html += "</body></html>"
    return html

def create_scorm_package(flow: ProcessFlow, output_path: str):
    """
    FR-19: Create SCORM 1.2 Compliance Package (ZIP).
    Includes imsmanifest.xml, content.html, AND video clips.
    """
    import zipfile
    
    # 1. Generate Content (With embedded clip links)
    html_content = export_to_html(flow, embed_clips=True)
    
    # 2. Generate Manifest
    # Simplified SCORM 1.2 manifest
    manifest = f"""<?xml version="1.0" standalone="no" ?>
<manifest identifier="TRAINFLOW_{flow.id}" version="1.0"
    xmlns="http://www.imsproject.org/xsd/imscp_rootv1p1p2"
    xmlns:adlcp="http://www.adlnet.org/xsd/adlcp_rootv1p2"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.imsproject.org/xsd/imscp_rootv1p1p2 imscp_rootv1p1p2.xsd
                        http://www.imsglobal.org/xsd/imsmd_rootv1p2p1 imsmd_rootv1p2p1.xsd
                        http://www.adlnet.org/xsd/adlcp_rootv1p2 adlcp_rootv1p2.xsd">
    <metadata>
        <schema>ADL SCORM</schema>
        <schemaversion>1.2</schemaversion>
    </metadata>
    <organizations default="ORG_{flow.id}">
        <organization identifier="ORG_{flow.id}">
            <title>{flow.title}</title>
            <item identifier="ITEM_{flow.id}" identifierref="RES_{flow.id}">
                <title>{flow.title}</title>
            </item>
        </organization>
    </organizations>
    <resources>
        <resource identifier="RES_{flow.id}" type="webcontent" href="index.html" adlcp:scormtype="sco">
            <file href="index.html"/>
        </resource>
    </resources>
</manifest>
"""
    
    # 3. Zip it up
    with zipfile.ZipFile(output_path, 'w') as zf:
        zf.writestr('index.html', html_content)
        zf.writestr('imsmanifest.xml', manifest)
        
        # Add Clips to ZIP
        for step in flow.steps:
            if step.video_clip_path and step.video_clip_path != "placeholder.mp4":
                # Only add if file exists
                # Assuming video_clip_path stored in DB is relative e.g. "/data/clips/..."
                # We need to map it to local filesystem
                
                # In worker.py we saved as: /data/clips/... for DB (URL friendly)
                # But physically stored at /tmp/clip_... (Wait, worker.py line 132 says /tmp)
                # Let's check worker.py's implementation again or assumes access.
                # Export service usually runs in same container, so it can access.
                
                # Logic: Try to find the file.
                # If path starts with /data/, map to likely volume. 
                # Or if just filename, check /tmp.
                # worker.py: clip_local_path = os.path.join("/tmp", clip_filename)
                # then refined_step["video_clip_path"] = f"/data/clips/{clip_filename}"
                
                filename = os.path.basename(step.video_clip_path)
                local_path = f"/tmp/{filename}" # Simple assumption for this prototype based on worker.py
                
                if os.path.exists(local_path):
                    zf.write(local_path, arcname=f"clips/{filename}")
                    
    return output_path
